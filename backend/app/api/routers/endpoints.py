from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
from app.db.base import get_db
from app.db.models import Game, Player
from app.api.services.game import BowlingGame
from app.db.schemas import RollRequest
from app.api.services.llm import get_llm_summary

router = APIRouter()


class CreateGameRequest(BaseModel):
    player_name: str  # accept player_name to create a new player if they don't exist


@router.post("/games")
async def create_game(request: CreateGameRequest, db: Session = Depends(get_db)):
    """
    Create a new bowling game for a single player.
    """
    # Check if the player exists in the database by their name
    player = db.query(Player).filter(Player.name == request.player_name).first()

    # If player does not exist, create a new player with the provided name
    if not player:
        player = Player(name=request.player_name)
        db.add(player)
        db.commit()
        db.refresh(player)

    # Create the game for the existing or newly created player
    game = Game(player_id=player.id)
    db.add(game)
    db.commit()
    db.refresh(game)

    return {"game_id": game.id, "player_id": player.id, "player_name": player.name}


@router.post("/games/{game_id}/rolls")
async def record_roll(
    game_id: str, request: RollRequest, db: Session = Depends(get_db)
):
    """
    Record a roll for the given game ID. Updates the frame and calculates the score.
    Args:
        game_id: The ID of the game.
        request: A request object with the number of pins knocked down.
        db: Database session dependency.
    Returns:
        JSON response with the current score after the roll.
    """
    game = db.query(Game).filter(Game.id == game_id).first()
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")

    bowling_game = BowlingGame(game)
    bowling_game.add_roll(request.pins_knocked)
    db.commit()
    return {"game_id": game_id, "current_score": bowling_game.calculate_score()}


# Get the current score
@router.get("/games/{game_id}/score")
async def get_score(game_id: str, db: Session = Depends(get_db)):
    """
    Get the current score for the given game ID.

    Args:
        game_id: The ID of the game.
        db: Database session dependency.

    Returns:
        JSON response with the current score.
    """
    game = db.query(Game).filter(Game.id == game_id).first()
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")

    bowling_game = BowlingGame(game)
    return {"game_id": game_id, "score": bowling_game.calculate_score()}


# Get a game summary using LLM
@router.get("/games/{game_id}/summary")
async def get_summary(game_id: str, model: str = "gpt", db: Session = Depends(get_db)):
    """
    Get a natural language summary of the game using the specified LLM model (GPT, BERT, T5, LLaMA).

    Args:
        game_id: The ID of the game.
        model: The LLM model to use for summarization (default is GPT).
        db: Database session dependency.

    Returns:
        JSON response with the game summary generated by the LLM.
    """
    game = db.query(Game).filter(Game.id == game_id).first()
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")

    summary = get_llm_summary(game, model)
    return {"game_id": game_id, "summary": summary}
